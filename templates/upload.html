{% extends "base.html" %}
{% block title %}Upload Images • E‑Ink Frame{% endblock %}

{% block content %}
<h1>Upload Images</h1>
<form id="uploadForm" enctype="multipart/form-data">
  <div>
    <label>
      <span>Select Images</span>
      <input type="file" name="files" accept="image/*" multiple required>
      <small>Hold Ctrl (or Cmd on Mac) to select multiple images</small>
      <div id="safariNotice" style="display: none; background: #ff9500; color: #000; padding: 0.5rem; border-radius: 4px; margin-top: 0.5rem; font-size: 0.85rem;">
        <strong>Safari on iOS:</strong> For best results, upload 5 or fewer images at a time. Larger batches may fail due to browser limitations.
      </div>
    </label>
  </div>
  <button type="submit" id="uploadBtn">Upload Images</button>
  
  <div id="uploadProgress" style="display: none;">
    <div id="progressText">Uploading images...</div>
    <div id="progressBar" style="width: 100%; background: #333; border-radius: 4px; margin-top: 0.5rem;">
      <div id="progressFill" style="width: 0%; height: 20px; background: #0066cc; border-radius: 4px; transition: width 0.3s;"></div>
    </div>
    <div id="progressDetails" style="margin-top: 0.5rem; font-size: 0.9rem; color: #ccc;"></div>
  </div>
  
  <div id="uploadComplete" style="display: none;">
    <div style="color: #28a745; font-weight: bold; margin-top: 1rem;">Upload completed!</div>
    <button onclick="goToGallery()" style="margin-top: 0.5rem;">Go to Gallery</button>
  </div>
  
  <div id="uploadErrors" style="display: none; margin-top: 1rem;">
    <div style="color: #dc3545; font-weight: bold;">Some uploads failed:</div>
    <ul id="errorList" style="color: #dc3545; margin-top: 0.5rem;"></ul>
  </div>
</form>

<script>
let currentTaskId = null;
let statusInterval = null;
let isUploading = false; // Prevent double submissions

document.getElementById('uploadForm').addEventListener('submit', async function(e) {
  e.preventDefault();
  
  // Prevent double submissions
  if (isUploading) {
    console.log('Upload already in progress, ignoring submission');
    return;
  }
  
  const fileInput = document.querySelector('input[type="file"]');
  const files = fileInput.files;
  
  if (files.length === 0) {
    alert('Please select at least one image to upload.');
    return;
  }
  
  // Safari iOS specific: Limit batch size for better stability
  const isSafariIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
  const maxBatchSize = isSafariIOS ? 5 : 20;
  
  if (files.length > maxBatchSize) {
    const message = isSafariIOS 
      ? `Safari on iOS works best with ${maxBatchSize} or fewer images at a time. You've selected ${files.length} images. Please select fewer images or use a desktop browser for large batches.`
      : `You've selected ${files.length} images. This might take a while. Continue?`;
    
    if (isSafariIOS) {
      alert(message);
      return;
    } else if (!confirm(message)) {
      return;
    }
  }
  
  // Set uploading flag and update UI
  isUploading = true;
  
  // Reset UI
  document.getElementById('uploadProgress').style.display = 'block';
  document.getElementById('uploadComplete').style.display = 'none';
  document.getElementById('uploadErrors').style.display = 'none';
  
  const submitBtn = document.getElementById('uploadBtn');
  submitBtn.disabled = true;
  submitBtn.textContent = 'Starting upload...';
  
  try {
    // Safari iOS specific: Create FormData more carefully
    const formData = new FormData();
    
    // Add files one by one with error handling for Safari
    for (let i = 0; i < files.length; i++) {
      try {
        formData.append('files', files[i]);
        console.log(`Added file ${i + 1}/${files.length}: ${files[i].name}`);
      } catch (error) {
        console.error(`Failed to add file ${files[i].name}:`, error);
        throw new Error(`Failed to prepare file ${files[i].name} for upload`);
      }
    }
    
    // Safari iOS specific: Add longer timeout and retry logic
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), 60000); // 60 second timeout
    
    let response;
    let retries = isSafariIOS ? 2 : 0; // Allow retries on Safari iOS
    
    while (retries >= 0) {
      try {
        response = await fetch('/upload', {
          method: 'POST',
          body: formData,
          signal: controller.signal
        });
        
        clearTimeout(timeoutId);
        break; // Success, exit retry loop
        
      } catch (error) {
        if (retries > 0 && (error.name === 'AbortError' || error.name === 'TypeError')) {
          console.log(`Upload attempt failed, retrying... (${retries} retries left)`);
          retries--;
          await new Promise(resolve => setTimeout(resolve, 2000)); // Wait 2 seconds before retry
          continue;
        }
        throw error; // No more retries or different error
      }
    }
    
    if (!response) {
      throw new Error('Upload failed after retries');
    }
    
    const result = await response.json();
    
    if (!response.ok) {
      throw new Error(result.error || 'Upload failed');
    }
    
    currentTaskId = result.task_id;
    document.getElementById('progressText').textContent = `Upload queued (${files.length} files)`;
    
    // Start polling for status with Safari-friendly interval
    const pollInterval = isSafariIOS ? 1000 : 500; // Slower polling on Safari iOS
    statusInterval = setInterval(checkUploadStatus, pollInterval);
    
  } catch (error) {
    console.error('Upload error:', error);
    let errorMessage = error.message;
    
    // Safari-specific error messages
    if (error.name === 'AbortError') {
      errorMessage = 'Upload timed out. Please try with fewer images or check your connection.';
    } else if (error.name === 'TypeError' && error.message.includes('network')) {
      errorMessage = 'Network error. Please check your connection and try again.';
    }
    
    document.getElementById('progressText').textContent = 'Upload failed: ' + errorMessage;
    submitBtn.disabled = false;
    submitBtn.textContent = 'Upload Images';
    isUploading = false; // Reset upload flag on error
  }
});

async function checkUploadStatus() {
  if (!currentTaskId) return;
  
  try {
    // Safari iOS specific: Add timeout to status checks
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), 10000); // 10 second timeout for status checks
    
    const response = await fetch(`/upload/status/${currentTaskId}`, {
      signal: controller.signal
    });
    
    clearTimeout(timeoutId);
    
    const status = await response.json();
    
    if (!response.ok) {
      throw new Error('Failed to get upload status');
    }
    
    // Update progress
    const progress = status.total > 0 ? (status.progress / status.total) * 100 : 0;
    document.getElementById('progressFill').style.width = progress + '%';
    
    // Update text
    if (status.status === 'queued') {
      document.getElementById('progressText').textContent = 'Upload queued...';
    } else if (status.status === 'processing') {
      document.getElementById('progressText').textContent = `Processing images...`;
      document.getElementById('progressDetails').textContent = 
        `${status.uploaded} of ${status.total} images processed`;
        
      // Safari iOS: Add current file info if available
      if (status.current_file) {
        document.getElementById('progressDetails').textContent += ` (${status.current_file})`;
      }
    } else if (status.status === 'completed') {
      // Upload finished
      clearInterval(statusInterval);
      statusInterval = null; // Clear reference
      document.getElementById('progressText').textContent = 'Upload completed!';
      document.getElementById('progressDetails').textContent = 
        `Successfully uploaded ${status.uploaded} of ${status.total} images`;
      document.getElementById('uploadComplete').style.display = 'block';
      
      // Show errors if any
      if (status.errors && status.errors.length > 0) {
        showErrors(status.errors);
      }
      
      // Reset button and upload flag
      const submitBtn = document.getElementById('uploadBtn');
      submitBtn.disabled = false;
      submitBtn.textContent = 'Upload Images';
      isUploading = false; // Reset upload flag on completion
      
    } else if (status.status === 'error') {
      // Upload failed
      clearInterval(statusInterval);
      statusInterval = null; // Clear reference
      document.getElementById('progressText').textContent = 'Upload failed';
      showErrors(status.errors || ['Unknown error occurred']);
      
      const submitBtn = document.getElementById('uploadBtn');
      submitBtn.disabled = false;
      submitBtn.textContent = 'Upload Images';
      isUploading = false; // Reset upload flag on error
    }
    
  } catch (error) {
    console.error('Status check error:', error);
    
    // Safari-specific error handling
    if (error.name === 'AbortError') {
      console.log('Status check timed out, will retry on next interval');
      return; // Don't stop polling on timeout, just skip this check
    }
    
    // For other errors, stop polling
    clearInterval(statusInterval);
    statusInterval = null;
    document.getElementById('progressText').textContent = 'Error checking upload status';
    
    // Reset state on persistent errors
    const submitBtn = document.getElementById('uploadBtn');
    submitBtn.disabled = false;
    submitBtn.textContent = 'Upload Images';
    isUploading = false;
  }
}

function showErrors(errors) {
  const errorDiv = document.getElementById('uploadErrors');
  const errorList = document.getElementById('errorList');
  errorList.innerHTML = '';
  
  errors.forEach(error => {
    const li = document.createElement('li');
    li.textContent = error;
    errorList.appendChild(li);
  });
  
  errorDiv.style.display = 'block';
}

// Show file count when files are selected
document.querySelector('input[type="file"]').addEventListener('change', function(e) {
  const count = e.target.files.length;
  const existing = document.getElementById('fileCount');
  if (existing) existing.remove();
  
  if (count > 0) {
    const div = document.createElement('div');
    div.id = 'fileCount';
    div.style.cssText = 'color: #0066cc; font-weight: bold; margin-top: 0.5rem;';
    div.textContent = `${count} image${count === 1 ? '' : 's'} selected`;
    e.target.parentNode.appendChild(div);
    
    // Show Safari warning if needed
    const isSafariIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
    if (isSafariIOS && count > 5) {
      div.style.color = '#ff9500';
      div.textContent += ' - Consider uploading in smaller batches for better reliability';
    }
  }
});

// Show Safari notice on page load if on Safari iOS
document.addEventListener('DOMContentLoaded', function() {
  const isSafariIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
  if (isSafariIOS) {
    document.getElementById('safariNotice').style.display = 'block';
  }
});

function goToGallery() {
  console.log('[UPLOAD] Go to Gallery button clicked - cleaning up state');
  
  // Clear any remaining intervals
  if (statusInterval) {
    clearInterval(statusInterval);
    statusInterval = null;
  }
  
  // Reset all state
  currentTaskId = null;
  isUploading = false;
  
  // Clear form
  document.getElementById('uploadForm').reset();
  
  // Hide all progress/status elements
  document.getElementById('uploadProgress').style.display = 'none';
  document.getElementById('uploadComplete').style.display = 'none';
  document.getElementById('uploadErrors').style.display = 'none';
  
  // Reset button state
  const submitBtn = document.getElementById('uploadBtn');
  submitBtn.disabled = false;
  submitBtn.textContent = 'Upload Images';
  
  console.log('[UPLOAD] State cleared, navigating to gallery');
  
  // Navigate to gallery
  window.location.href = '/';
}
</script>

<style>
  label {
    display: block;
    margin-bottom: 1rem;
  }
  label span {
    display: block;
    font-weight: bold;
    margin-bottom: 0.25rem;
  }
  input[type="file"] {
    width: 100%;
    padding: 0.5rem;
    border: 2px dashed #666;
    border-radius: 4px;
    background: #222;
    color: #eee;
  }
  input[type="text"], textarea {
    width: 100%;
    padding: 0.5rem;
    border: 1px solid #666;
    border-radius: 4px;
    background: #222;
    color: #eee;
  }
  small {
    display: block;
    color: #999;
    font-size: 0.8rem;
    margin-top: 0.25rem;
  }
  button {
    background: #0066cc;
    color: white;
    border: none;
    padding: 0.75rem 1.5rem;
    border-radius: 4px;
    cursor: pointer;
    font-size: 1rem;
  }
  button:hover {
    background: #0052a3;
  }
  button:disabled {
    background: #666;
    cursor: not-allowed;
  }
</style>
{% endblock %}
