{% extends "base.html" %}
{% block title %}Home ‚Ä¢ E‚ÄëInk Frame{% endblock %}

{% block content %}

{% if images %}
<div class="row">
  <div class="current">    
    <div class="current-image">
      {% if current_image_exists %}
        <img id="currentPreview" src="/static/current.jpg" alt="Current Image"><br/>
        <span>Current Image</span>
      {% else %}
        <div class="placeholder-image">
          <div class="placeholder-icon">üñºÔ∏è</div>
          <span>No Current Image</span>
          <p class="placeholder-text">
            {% if images %}
              Processing... Current image will appear shortly
            {% else %}
              Upload images to get started
            {% endif %}
          </p>
        </div>
      {% endif %}
    </div>
  </div>
</div>


<h1>Library</h1>
<div class="grid">
  {% for image in images %}
    {% include 'partials/_image_card.html' %}
  {% endfor %}
</div>
{% else %}
<div class="empty-state">
  <div class="empty-content">
    <div class="empty-icon">üì∏</div>
    <h2>No Images Yet</h2>
    <p>Your photo frame is empty! Get started by uploading some images to create your personal gallery.</p>
    <div class="empty-actions">
      <a href="/upload" class="upload-button">
        <span class="upload-icon">‚¨ÜÔ∏è</span>
        Upload Your First Images
      </a>
    </div>
    <div class="empty-tips">
      <h3>üí° Tips:</h3>
      <ul>
        <li>Select multiple images at once for bulk upload</li>
        <li>Use the crop tool to perfectly frame your photos</li>
        <li>Enable slideshow mode to automatically update images</li>
        <li>Toggle images on/off to control what appears in rotation</li>
      </ul>
    </div>
  </div>
</div>
{% endif %}

<script>
// Global settings
const displaySettings = {
  width: {% if settings and settings.resolution %}{{ settings.resolution.split(',')[0] }}{% else %}800{% endif %},
  height: {% if settings and settings.resolution %}{{ settings.resolution.split(',')[1] }}{% else %}480{% endif %}
};

// Calculate aspect ratio from display settings
const displayAspectRatio = displaySettings.width / displaySettings.height;

let currentCropId = null;
let isDragging = false;
let isResizing = false;
let dragStartX = 0;
let dragStartY = 0;
let cropStartLeft = 0;
let cropStartTop = 0;
let cropStartWidth = 0;
let cropStartHeight = 0;

document.addEventListener('click', async (e) => {
  // EDIT IMAGE
  const editBtn = e.target.closest('.edit-image');
  if (editBtn) {
    e.preventDefault();
    const id = editBtn.dataset.id;
    
    // Hide display elements and show edit elements
    document.getElementById(`title-display-${id}`).style.display = 'none';
    const descDisplay = document.getElementById(`desc-display-${id}`);
    if (descDisplay) descDisplay.style.display = 'none';
    document.getElementById(`title-edit-${id}`).style.display = 'block';
    
    // Don't initialize crop tool automatically - let user expand crop settings first
    
    return;
  }

  // SAVE EDIT
  const saveBtn = e.target.closest('.save-edit');
  if (saveBtn) {
    e.preventDefault();
    const id = saveBtn.dataset.id;
    const title = document.getElementById(`title-input-${id}`).value;
    const description = document.getElementById(`desc-input-${id}`).value;
    const cropX = document.getElementById(`crop-x-${id}`).value;
    const cropY = document.getElementById(`crop-y-${id}`).value;
    const cropWidth = document.getElementById(`crop-width-${id}`).value;
    const cropHeight = document.getElementById(`crop-height-${id}`).value;
    const preserveAspectRatio = document.getElementById(`preserve-aspect-${id}`).checked;
    
    try {
      const formData = new FormData();
      formData.append('title', title);
      formData.append('description', description);
      formData.append('crop_x', cropX);
      formData.append('crop_y', cropY);
      formData.append('crop_width', cropWidth);
      formData.append('crop_height', cropHeight);
      formData.append('preserve_aspect_ratio', preserveAspectRatio);
      
      const res = await fetch(`/image/${id}/update`, { 
        method: 'POST',
        body: formData
      });
      if (!res.ok) throw new Error('Bad response');
      
      // Update display elements
      document.getElementById(`title-display-${id}`).textContent = title;
      
      // Update or create description display
      let descDisplay = document.getElementById(`desc-display-${id}`);
      if (description.trim()) {
        if (!descDisplay) {
          descDisplay = document.createElement('div');
          descDisplay.className = 'description';
          descDisplay.id = `desc-display-${id}`;
          document.getElementById(`title-display-${id}`).parentNode.appendChild(descDisplay);
        }
        descDisplay.textContent = description;
        descDisplay.style.display = 'block';
      } else if (descDisplay) {
        descDisplay.style.display = 'none';
      }
      
      // Hide edit elements and show display elements
      document.getElementById(`title-edit-${id}`).style.display = 'none';
      document.getElementById(`title-display-${id}`).style.display = 'block';
      
    } catch (err) {
      alert('Failed to update image.');
      console.error(err);
    }
    return;
  }

  // CANCEL EDIT
  const cancelBtn = e.target.closest('.cancel-edit');
  if (cancelBtn) {
    e.preventDefault();
    const id = cancelBtn.dataset.id;
    
    // Hide edit elements and show display elements
    document.getElementById(`title-edit-${id}`).style.display = 'none';
    document.getElementById(`title-display-${id}`).style.display = 'block';
    const descDisplay = document.getElementById(`desc-display-${id}`);
    if (descDisplay) descDisplay.style.display = 'block';
    
    return;
  }

  // SHOW NOW
  const showBtn = e.target.closest('.show-now');
  if (showBtn) {
    e.preventDefault();
    const id = showBtn.dataset.id;
    const originalText = showBtn.textContent;
    showBtn.textContent = '‚è≥'; // Loading indicator
    showBtn.disabled = true;
    
    try {
      const res = await fetch(`/show-now/${id}`, { method: 'POST' });
      if (!res.ok) throw new Error('Bad response');
      
      // Update the current preview image
      const img = document.querySelector('#currentPreview');
      if (img) {
        img.src = `/static/current.jpg?ts=${Date.now()}`; // bust cache
        
        // Add a brief visual indicator that the image was updated
        img.style.border = '3px solid #28a745';
        setTimeout(() => {
          img.style.border = '';
        }, 2000);
      }
      
      // Show success feedback
      showBtn.textContent = '‚úÖ';
      setTimeout(() => {
        showBtn.textContent = originalText;
        showBtn.disabled = false;
      }, 1500);
      
    } catch (err) {
      alert('Failed to show image now.');
      console.error(err);
      showBtn.textContent = originalText;
      showBtn.disabled = false;
    }
    return;
  }

  // TOGGLE ENABLED
  const toggleBtn = e.target.closest('.toggle-enabled');
  if (toggleBtn) {
    e.preventDefault();
    const id = toggleBtn.dataset.id;
    try {
      const res = await fetch(`/image/${id}/toggle`, { method: 'POST' });
      if (!res.ok) throw new Error('Bad response');
      const data = await res.json(); // { enabled: true|false }

      // Update button label and aria-pressed
      toggleBtn.textContent = data.enabled ? 'Disable' : 'Enable';
      toggleBtn.setAttribute('aria-pressed', data.enabled ? 'true' : 'false');

      // Optional: visually mark disabled cards
      const card = document.getElementById(`img-${id}`);
      if (card) card.classList.toggle('is-disabled', !data.enabled);
    } catch (err) {
      alert('Failed to toggle image.');
      console.error(err);
    }
  }

     // DELETE Button
  const deleteBtn = e.target.closest('.delete-image');
  if (deleteBtn) {
    e.preventDefault();
    const id = deleteBtn.dataset.id;

    if (!confirm('Are you sure you want to delete this image?')) return;

    try {
      const res = await fetch(`/image/${id}/delete`, { method: 'POST' });
      if (!res.ok) throw new Error('Bad response');
      const card = document.getElementById(`img-${id}`);
      if (card) card.remove();
    } catch (err) {
      alert('Failed to delete image.');
      console.error(err);
    }
  }

});

// Initialize crop tool for an image
function initializeCropTool(imageId) {
  currentCropId = imageId;
  const cropContainer = document.getElementById(`crop-container-${imageId}`);
  const cropSelector = document.getElementById(`crop-selector-${imageId}`);
  
  if (!cropContainer || !cropSelector) return;
  
  // Get current crop values
  const cropX = parseFloat(document.getElementById(`crop-x-${imageId}`).value);
  const cropY = parseFloat(document.getElementById(`crop-y-${imageId}`).value);
  const cropWidth = parseFloat(document.getElementById(`crop-width-${imageId}`).value);
  const cropHeight = parseFloat(document.getElementById(`crop-height-${imageId}`).value);
  
  // Update crop selector position and size
  updateCropSelectorPosition(imageId, cropX, cropY, cropWidth, cropHeight);
  
  // Add event listeners for dragging
  setupCropDragHandlers(imageId);
}

// Update crop selector position and size based on percentages
function updateCropSelectorPosition(imageId, cropX, cropY, cropWidth, cropHeight) {
  const cropSelector = document.getElementById(`crop-selector-${imageId}`);
  if (!cropSelector) return;
  
  cropSelector.style.left = `${cropX}%`;
  cropSelector.style.top = `${cropY}%`;
  cropSelector.style.width = `${cropWidth}%`;
  cropSelector.style.height = `${cropHeight}%`;
}

// Setup drag handlers for crop selector
function setupCropDragHandlers(imageId) {
  const cropSelector = document.getElementById(`crop-selector-${imageId}`);
  const cropContainer = document.getElementById(`crop-container-${imageId}`);
  
  if (!cropSelector || !cropContainer) return;
  
  // Main crop area dragging - mouse events
  cropSelector.addEventListener('mousedown', (e) => {
    if (e.target.classList.contains('crop-handle')) return; // Don't drag if clicking on handle
    
    isDragging = true;
    dragStartX = e.clientX;
    dragStartY = e.clientY;
    
    const rect = cropSelector.getBoundingClientRect();
    cropStartLeft = rect.left;
    cropStartTop = rect.top;
    
    e.preventDefault();
  });
  
  // Main crop area dragging - touch events
  cropSelector.addEventListener('touchstart', (e) => {
    if (e.target.classList.contains('crop-handle')) return; // Don't drag if touching handle
    
    isDragging = true;
    const touch = e.touches[0];
    dragStartX = touch.clientX;
    dragStartY = touch.clientY;
    
    const rect = cropSelector.getBoundingClientRect();
    cropStartLeft = rect.left;
    cropStartTop = rect.top;
    
    e.preventDefault();
  });
  
  // Handle resizing - mouse events
  const handles = cropSelector.querySelectorAll('.crop-handle');
  handles.forEach(handle => {
    handle.addEventListener('mousedown', (e) => {
      isResizing = true;
      isDragging = false;
      
      dragStartX = e.clientX;
      dragStartY = e.clientY;
      
      const rect = cropSelector.getBoundingClientRect();
      cropStartLeft = rect.left;
      cropStartTop = rect.top;
      cropStartWidth = rect.width;
      cropStartHeight = rect.height;
      
      e.preventDefault();
      e.stopPropagation();
    });
    
    // Handle resizing - touch events
    handle.addEventListener('touchstart', (e) => {
      isResizing = true;
      isDragging = false;
      
      const touch = e.touches[0];
      dragStartX = touch.clientX;
      dragStartY = touch.clientY;
      
      const rect = cropSelector.getBoundingClientRect();
      cropStartLeft = rect.left;
      cropStartTop = rect.top;
      cropStartWidth = rect.width;
      cropStartHeight = rect.height;
      
      e.preventDefault();
      e.stopPropagation();
    });
  });
  
  // Mouse move handler
  document.addEventListener('mousemove', (e) => {
    if (!isDragging && !isResizing) return;
    if (currentCropId !== imageId) return;
    
    const containerRect = cropContainer.getBoundingClientRect();
    const deltaX = e.clientX - dragStartX;
    const deltaY = e.clientY - dragStartY;
    
    if (isDragging) {
      // Move the crop selector
      let newLeft = cropStartLeft + deltaX - containerRect.left;
      let newTop = cropStartTop + deltaY - containerRect.top;
      
      const selectorRect = cropSelector.getBoundingClientRect();
      const maxLeft = containerRect.width - selectorRect.width;
      const maxTop = containerRect.height - selectorRect.height;
      
      newLeft = Math.max(0, Math.min(newLeft, maxLeft));
      newTop = Math.max(0, Math.min(newTop, maxTop));
      
      const leftPercent = (newLeft / containerRect.width) * 100;
      const topPercent = (newTop / containerRect.height) * 100;
      
      updateCropValues(imageId, leftPercent, topPercent, null, null);
      
    } else if (isResizing) {
      // Resize the crop selector with proper aspect ratio constraints
      let newWidth = cropStartWidth + deltaX;
      let newHeight = cropStartHeight + deltaY;
      
      // Get current position for boundary calculations
      const currentLeft = cropStartLeft - containerRect.left;
      const currentTop = cropStartTop - containerRect.top;
      
      // Calculate maximum possible dimensions based on container bounds
      const maxWidth = containerRect.width - currentLeft;
      const maxHeight = containerRect.height - currentTop;
      
      // Apply minimum size constraints first
      newWidth = Math.max(50, newWidth);
      newHeight = Math.max(30, newHeight);
      
      // Maintain aspect ratio while respecting bounds
      const targetAspectRatio = displayAspectRatio;
      
      // Try width-constrained approach first
      let constrainedWidth = Math.min(newWidth, maxWidth);
      let constrainedHeight = constrainedWidth / targetAspectRatio;
      
      // If height exceeds bounds, switch to height-constrained approach
      if (constrainedHeight > maxHeight) {
        constrainedHeight = Math.min(newHeight, maxHeight);
        constrainedWidth = constrainedHeight * targetAspectRatio;
      }
      
      // Final check - ensure both dimensions fit
      constrainedWidth = Math.min(constrainedWidth, maxWidth);
      constrainedHeight = Math.min(constrainedHeight, maxHeight);
      
      // Ensure we maintain minimum sizes after constraints
      if (constrainedWidth < 50 || constrainedHeight < 30) {
        // If we can't maintain minimums, keep current size
        constrainedWidth = cropStartWidth;
        constrainedHeight = cropStartHeight;
      }
      
      const widthPercent = (constrainedWidth / containerRect.width) * 100;
      const heightPercent = (constrainedHeight / containerRect.height) * 100;
      
      updateCropValues(imageId, null, null, widthPercent, heightPercent);
    }
  });
  
  // Touch move handler
  document.addEventListener('touchmove', (e) => {
    if (!isDragging && !isResizing) return;
    if (currentCropId !== imageId) return;
    
    const touch = e.touches[0];
    const containerRect = cropContainer.getBoundingClientRect();
    const deltaX = touch.clientX - dragStartX;
    const deltaY = touch.clientY - dragStartY;
    
    if (isDragging) {
      // Move the crop selector
      let newLeft = cropStartLeft + deltaX - containerRect.left;
      let newTop = cropStartTop + deltaY - containerRect.top;
      
      const selectorRect = cropSelector.getBoundingClientRect();
      const maxLeft = containerRect.width - selectorRect.width;
      const maxTop = containerRect.height - selectorRect.height;
      
      newLeft = Math.max(0, Math.min(newLeft, maxLeft));
      newTop = Math.max(0, Math.min(newTop, maxTop));
      
      const leftPercent = (newLeft / containerRect.width) * 100;
      const topPercent = (newTop / containerRect.height) * 100;
      
      updateCropValues(imageId, leftPercent, topPercent, null, null);
      
    } else if (isResizing) {
      // Resize the crop selector with proper aspect ratio constraints
      let newWidth = cropStartWidth + deltaX;
      let newHeight = cropStartHeight + deltaY;
      
      // Get current position for boundary calculations
      const currentLeft = cropStartLeft - containerRect.left;
      const currentTop = cropStartTop - containerRect.top;
      
      // Calculate maximum possible dimensions based on container bounds
      const maxWidth = containerRect.width - currentLeft;
      const maxHeight = containerRect.height - currentTop;
      
      // Apply minimum size constraints first
      newWidth = Math.max(50, newWidth);
      newHeight = Math.max(30, newHeight);
      
      // Maintain aspect ratio while respecting bounds
      const targetAspectRatio = displayAspectRatio;
      
      // Try width-constrained approach first
      let constrainedWidth = Math.min(newWidth, maxWidth);
      let constrainedHeight = constrainedWidth / targetAspectRatio;
      
      // If height exceeds bounds, switch to height-constrained approach
      if (constrainedHeight > maxHeight) {
        constrainedHeight = Math.min(newHeight, maxHeight);
        constrainedWidth = constrainedHeight * targetAspectRatio;
      }
      
      // Final check - ensure both dimensions fit
      constrainedWidth = Math.min(constrainedWidth, maxWidth);
      constrainedHeight = Math.min(constrainedHeight, maxHeight);
      
      // Ensure we maintain minimum sizes after constraints
      if (constrainedWidth < 50 || constrainedHeight < 30) {
        // If we can't maintain minimums, keep current size
        constrainedWidth = cropStartWidth;
        constrainedHeight = cropStartHeight;
      }
      
      const widthPercent = (constrainedWidth / containerRect.width) * 100;
      const heightPercent = (constrainedHeight / containerRect.height) * 100;
      
      updateCropValues(imageId, null, null, widthPercent, heightPercent);
    }
    
    e.preventDefault(); // Prevent page scrolling during crop operations
  });
  
  // Mouse up handler
  document.addEventListener('mouseup', () => {
    isDragging = false;
    isResizing = false;
  });
  
  // Touch end handler
  document.addEventListener('touchend', () => {
    isDragging = false;
    isResizing = false;
  });
}

// Update crop input values and selector position
function updateCropValues(imageId, x, y, width, height) {
  const cropXInput = document.getElementById(`crop-x-${imageId}`);
  const cropYInput = document.getElementById(`crop-y-${imageId}`);
  const cropWidthInput = document.getElementById(`crop-width-${imageId}`);
  const cropHeightInput = document.getElementById(`crop-height-${imageId}`);
  
  if (x !== null) cropXInput.value = Math.round(x * 100) / 100;
  if (y !== null) cropYInput.value = Math.round(y * 100) / 100;
  if (width !== null) cropWidthInput.value = Math.round(width * 100) / 100;
  if (height !== null) cropHeightInput.value = Math.round(height * 100) / 100;
  
  // Update visual position
  const currentX = parseFloat(cropXInput.value);
  const currentY = parseFloat(cropYInput.value);
  const currentWidth = parseFloat(cropWidthInput.value);
  const currentHeight = parseFloat(cropHeightInput.value);
  
  updateCropSelectorPosition(imageId, currentX, currentY, currentWidth, currentHeight);
}

// Toggle crop settings visibility
function toggleCropSettings(imageId) {
  const content = document.getElementById(`crop-content-${imageId}`);
  const toggle = document.getElementById(`crop-toggle-${imageId}`);
  
  if (content.style.display === 'none') {
    content.style.display = 'block';
    toggle.textContent = '‚ñ≤';
    // Initialize crop tool when expanded
    setTimeout(() => initializeCropTool(imageId), 100);
  } else {
    content.style.display = 'none';
    toggle.textContent = '‚ñº';
  }
}

// Toggle aspect ratio preservation mode
function toggleAspectRatioMode(imageId) {
  const preserveAspect = document.getElementById(`preserve-aspect-${imageId}`).checked;
  const cropControls = document.getElementById(`crop-controls-${imageId}`);
  
  if (preserveAspect) {
    // Disable crop controls when preserving aspect ratio
    cropControls.style.opacity = '0.5';
    cropControls.style.pointerEvents = 'none';
  } else {
    // Enable crop controls when crop-to-fill is selected
    cropControls.style.opacity = '';
    cropControls.style.pointerEvents = '';
  }
}
</script>
{% endblock %}
