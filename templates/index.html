{% extends "base.html" %}
{% block title %}Home • E‑Ink Frame{% endblock %}

{% block content %}
<h1>Library</h1>
<div class="row">
  
  <div class="current">    
    <div class="current-image">
      <img id="currentPreview" src="/static/current.jpg" alt="Current Image"><br/>
      <span>Current Image</span>
    </div>
  </div>
</div>

<div class="grid">
  {% for image in images %}
    {% include 'partials/_image_card.html' %}
  {% endfor %}
</div>

<script>
// Global settings
const displaySettings = {
  width: {% if settings and settings.resolution %}{{ settings.resolution.split(',')[0] }}{% else %}800{% endif %},
  height: {% if settings and settings.resolution %}{{ settings.resolution.split(',')[1] }}{% else %}480{% endif %}
};

// Calculate aspect ratio from display settings
const displayAspectRatio = displaySettings.width / displaySettings.height;

let currentCropId = null;
let isDragging = false;
let isResizing = false;
let dragStartX = 0;
let dragStartY = 0;
let cropStartLeft = 0;
let cropStartTop = 0;
let cropStartWidth = 0;
let cropStartHeight = 0;

document.addEventListener('click', async (e) => {
  // EDIT IMAGE
  const editBtn = e.target.closest('.edit-image');
  if (editBtn) {
    e.preventDefault();
    const id = editBtn.dataset.id;
    
    // Hide display elements and show edit elements
    document.getElementById(`title-display-${id}`).style.display = 'none';
    const descDisplay = document.getElementById(`desc-display-${id}`);
    if (descDisplay) descDisplay.style.display = 'none';
    document.getElementById(`title-edit-${id}`).style.display = 'block';
    
    // Don't initialize crop tool automatically - let user expand crop settings first
    
    return;
  }

  // SAVE EDIT
  const saveBtn = e.target.closest('.save-edit');
  if (saveBtn) {
    e.preventDefault();
    const id = saveBtn.dataset.id;
    const title = document.getElementById(`title-input-${id}`).value;
    const description = document.getElementById(`desc-input-${id}`).value;
    const cropX = document.getElementById(`crop-x-${id}`).value;
    const cropY = document.getElementById(`crop-y-${id}`).value;
    const cropWidth = document.getElementById(`crop-width-${id}`).value;
    const cropHeight = document.getElementById(`crop-height-${id}`).value;
    const preserveAspectRatio = document.getElementById(`preserve-aspect-${id}`).checked;
    
    try {
      const formData = new FormData();
      formData.append('title', title);
      formData.append('description', description);
      formData.append('crop_x', cropX);
      formData.append('crop_y', cropY);
      formData.append('crop_width', cropWidth);
      formData.append('crop_height', cropHeight);
      formData.append('preserve_aspect_ratio', preserveAspectRatio);
      
      const res = await fetch(`/image/${id}/update`, { 
        method: 'POST',
        body: formData
      });
      if (!res.ok) throw new Error('Bad response');
      
      // Update display elements
      document.getElementById(`title-display-${id}`).textContent = title;
      
      // Update or create description display
      let descDisplay = document.getElementById(`desc-display-${id}`);
      if (description.trim()) {
        if (!descDisplay) {
          descDisplay = document.createElement('div');
          descDisplay.className = 'description';
          descDisplay.id = `desc-display-${id}`;
          document.getElementById(`title-display-${id}`).parentNode.appendChild(descDisplay);
        }
        descDisplay.textContent = description;
        descDisplay.style.display = 'block';
      } else if (descDisplay) {
        descDisplay.style.display = 'none';
      }
      
      // Hide edit elements and show display elements
      document.getElementById(`title-edit-${id}`).style.display = 'none';
      document.getElementById(`title-display-${id}`).style.display = 'block';
      
    } catch (err) {
      alert('Failed to update image.');
      console.error(err);
    }
    return;
  }

  // CANCEL EDIT
  const cancelBtn = e.target.closest('.cancel-edit');
  if (cancelBtn) {
    e.preventDefault();
    const id = cancelBtn.dataset.id;
    
    // Hide edit elements and show display elements
    document.getElementById(`title-edit-${id}`).style.display = 'none';
    document.getElementById(`title-display-${id}`).style.display = 'block';
    const descDisplay = document.getElementById(`desc-display-${id}`);
    if (descDisplay) descDisplay.style.display = 'block';
    
    return;
  }

  // SHOW NOW
  const showBtn = e.target.closest('.show-now');
  if (showBtn) {
    e.preventDefault();
    const id = showBtn.dataset.id;
    const originalText = showBtn.textContent;
    showBtn.textContent = '⏳'; // Loading indicator
    showBtn.disabled = true;
    
    try {
      const res = await fetch(`/show-now/${id}`, { method: 'POST' });
      if (!res.ok) throw new Error('Bad response');
      
      // Update the current preview image
      const img = document.querySelector('#currentPreview');
      if (img) {
        img.src = `/static/current.jpg?ts=${Date.now()}`; // bust cache
        
        // Add a brief visual indicator that the image was updated
        img.style.border = '3px solid #28a745';
        setTimeout(() => {
          img.style.border = '';
        }, 2000);
      }
      
      // Show success feedback
      showBtn.textContent = '✅';
      setTimeout(() => {
        showBtn.textContent = originalText;
        showBtn.disabled = false;
      }, 1500);
      
    } catch (err) {
      alert('Failed to show image now.');
      console.error(err);
      showBtn.textContent = originalText;
      showBtn.disabled = false;
    }
    return;
  }

  // TOGGLE ENABLED
  const toggleBtn = e.target.closest('.toggle-enabled');
  if (toggleBtn) {
    e.preventDefault();
    const id = toggleBtn.dataset.id;
    try {
      const res = await fetch(`/image/${id}/toggle`, { method: 'POST' });
      if (!res.ok) throw new Error('Bad response');
      const data = await res.json(); // { enabled: true|false }

      // Update button label and aria-pressed
      toggleBtn.textContent = data.enabled ? 'Disable' : 'Enable';
      toggleBtn.setAttribute('aria-pressed', data.enabled ? 'true' : 'false');

      // Optional: visually mark disabled cards
      const card = document.getElementById(`img-${id}`);
      if (card) card.classList.toggle('is-disabled', !data.enabled);
    } catch (err) {
      alert('Failed to toggle image.');
      console.error(err);
    }
  }

     // DELETE Button
  const deleteBtn = e.target.closest('.delete-image');
  if (deleteBtn) {
    e.preventDefault();
    const id = deleteBtn.dataset.id;

    if (!confirm('Are you sure you want to delete this image?')) return;

    try {
      const res = await fetch(`/image/${id}/delete`, { method: 'POST' });
      if (!res.ok) throw new Error('Bad response');
      const card = document.getElementById(`img-${id}`);
      if (card) card.remove();
    } catch (err) {
      alert('Failed to delete image.');
      console.error(err);
    }
  }

});

// Initialize crop tool for an image
function initializeCropTool(imageId) {
  currentCropId = imageId;
  const cropContainer = document.getElementById(`crop-container-${imageId}`);
  const cropSelector = document.getElementById(`crop-selector-${imageId}`);
  
  if (!cropContainer || !cropSelector) return;
  
  // Get current crop values
  const cropX = parseFloat(document.getElementById(`crop-x-${imageId}`).value);
  const cropY = parseFloat(document.getElementById(`crop-y-${imageId}`).value);
  const cropWidth = parseFloat(document.getElementById(`crop-width-${imageId}`).value);
  const cropHeight = parseFloat(document.getElementById(`crop-height-${imageId}`).value);
  
  // Update crop selector position and size
  updateCropSelectorPosition(imageId, cropX, cropY, cropWidth, cropHeight);
  
  // Add event listeners for dragging
  setupCropDragHandlers(imageId);
}

// Update crop selector position and size based on percentages
function updateCropSelectorPosition(imageId, cropX, cropY, cropWidth, cropHeight) {
  const cropSelector = document.getElementById(`crop-selector-${imageId}`);
  if (!cropSelector) return;
  
  cropSelector.style.left = `${cropX}%`;
  cropSelector.style.top = `${cropY}%`;
  cropSelector.style.width = `${cropWidth}%`;
  cropSelector.style.height = `${cropHeight}%`;
}

// Setup drag handlers for crop selector
function setupCropDragHandlers(imageId) {
  const cropSelector = document.getElementById(`crop-selector-${imageId}`);
  const cropContainer = document.getElementById(`crop-container-${imageId}`);
  
  if (!cropSelector || !cropContainer) return;
  
  // Main crop area dragging
  cropSelector.addEventListener('mousedown', (e) => {
    if (e.target.classList.contains('crop-handle')) return; // Don't drag if clicking on handle
    
    isDragging = true;
    dragStartX = e.clientX;
    dragStartY = e.clientY;
    
    const rect = cropSelector.getBoundingClientRect();
    cropStartLeft = rect.left;
    cropStartTop = rect.top;
    
    e.preventDefault();
  });
  
  // Handle resizing
  const handles = cropSelector.querySelectorAll('.crop-handle');
  handles.forEach(handle => {
    handle.addEventListener('mousedown', (e) => {
      isResizing = true;
      isDragging = false;
      
      dragStartX = e.clientX;
      dragStartY = e.clientY;
      
      const rect = cropSelector.getBoundingClientRect();
      cropStartLeft = rect.left;
      cropStartTop = rect.top;
      cropStartWidth = rect.width;
      cropStartHeight = rect.height;
      
      e.preventDefault();
      e.stopPropagation();
    });
  });
  
  // Mouse move handler
  document.addEventListener('mousemove', (e) => {
    if (!isDragging && !isResizing) return;
    if (currentCropId !== imageId) return;
    
    const containerRect = cropContainer.getBoundingClientRect();
    const deltaX = e.clientX - dragStartX;
    const deltaY = e.clientY - dragStartY;
    
    if (isDragging) {
      // Move the crop selector
      let newLeft = cropStartLeft + deltaX - containerRect.left;
      let newTop = cropStartTop + deltaY - containerRect.top;
      
      const selectorRect = cropSelector.getBoundingClientRect();
      const maxLeft = containerRect.width - selectorRect.width;
      const maxTop = containerRect.height - selectorRect.height;
      
      newLeft = Math.max(0, Math.min(newLeft, maxLeft));
      newTop = Math.max(0, Math.min(newTop, maxTop));
      
      const leftPercent = (newLeft / containerRect.width) * 100;
      const topPercent = (newTop / containerRect.height) * 100;
      
      updateCropValues(imageId, leftPercent, topPercent, null, null);
      
    } else if (isResizing) {
      // Resize the crop selector
      let newWidth = cropStartWidth + deltaX;
      let newHeight = cropStartHeight + deltaY;
      
      // Maintain aspect ratio
      const targetAspectRatio = displayAspectRatio;
      const currentAspectRatio = newWidth / newHeight;
      
      if (currentAspectRatio > targetAspectRatio) {
        newWidth = newHeight * targetAspectRatio;
      } else {
        newHeight = newWidth / targetAspectRatio;
      }
      
      // Ensure minimum size
      newWidth = Math.max(50, newWidth);
      newHeight = Math.max(30, newHeight);
      
      // Ensure doesn't exceed container
      const maxWidth = containerRect.width - (cropStartLeft - containerRect.left);
      const maxHeight = containerRect.height - (cropStartTop - containerRect.top);
      
      newWidth = Math.min(newWidth, maxWidth);
      newHeight = Math.min(newHeight, maxHeight);
      
      const widthPercent = (newWidth / containerRect.width) * 100;
      const heightPercent = (newHeight / containerRect.height) * 100;
      
      updateCropValues(imageId, null, null, widthPercent, heightPercent);
    }
  });
  
  // Mouse up handler
  document.addEventListener('mouseup', () => {
    isDragging = false;
    isResizing = false;
  });
}

// Update crop input values and selector position
function updateCropValues(imageId, x, y, width, height) {
  const cropXInput = document.getElementById(`crop-x-${imageId}`);
  const cropYInput = document.getElementById(`crop-y-${imageId}`);
  const cropWidthInput = document.getElementById(`crop-width-${imageId}`);
  const cropHeightInput = document.getElementById(`crop-height-${imageId}`);
  
  if (x !== null) cropXInput.value = Math.round(x * 100) / 100;
  if (y !== null) cropYInput.value = Math.round(y * 100) / 100;
  if (width !== null) cropWidthInput.value = Math.round(width * 100) / 100;
  if (height !== null) cropHeightInput.value = Math.round(height * 100) / 100;
  
  // Update visual position
  const currentX = parseFloat(cropXInput.value);
  const currentY = parseFloat(cropYInput.value);
  const currentWidth = parseFloat(cropWidthInput.value);
  const currentHeight = parseFloat(cropHeightInput.value);
  
  updateCropSelectorPosition(imageId, currentX, currentY, currentWidth, currentHeight);
}

// Toggle crop settings visibility
function toggleCropSettings(imageId) {
  const content = document.getElementById(`crop-content-${imageId}`);
  const toggle = document.getElementById(`crop-toggle-${imageId}`);
  
  if (content.style.display === 'none') {
    content.style.display = 'block';
    toggle.textContent = '▲';
    // Initialize crop tool when expanded
    setTimeout(() => initializeCropTool(imageId), 100);
  } else {
    content.style.display = 'none';
    toggle.textContent = '▼';
  }
}

// Toggle aspect ratio preservation mode
function toggleAspectRatioMode(imageId) {
  const preserveAspect = document.getElementById(`preserve-aspect-${imageId}`).checked;
  const cropControls = document.getElementById(`crop-controls-${imageId}`);
  
  if (preserveAspect) {
    // Disable crop controls when preserving aspect ratio
    cropControls.style.opacity = '0.5';
    cropControls.style.pointerEvents = 'none';
  } else {
    // Enable crop controls when crop-to-fill is selected
    cropControls.style.opacity = '';
    cropControls.style.pointerEvents = '';
  }
}
</script>
{% endblock %}
